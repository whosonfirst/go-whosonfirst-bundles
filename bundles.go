package bundles

import (
	"errors"
	"fmt"
	"github.com/whosonfirst/go-whosonfirst-bundles/compress"
	"github.com/whosonfirst/go-whosonfirst-clone"
	"github.com/whosonfirst/go-whosonfirst-log"
	"io"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"time"
)

type BundleOptions struct {
	Source       string
	Destination  string
	BundleName   string
	Compress     bool
	Dated        bool
	SkipExisting bool
	ForceUpdates bool
	Processes    int
	Logger       *log.WOFLogger
}

type Bundle struct {
	Options *BundleOptions
}

type BundleInfo struct {
	os.FileInfo
	path string
	info os.FileInfo
}

func (i *BundleInfo) Name() string {
	return i.info.Name()
}

func (i *BundleInfo) Size() int64 {
	return i.info.Size()
}

func (i *BundleInfo) Mode() os.FileMode {
	return i.info.Mode()
}

func (i *BundleInfo) ModTime() time.Time {
	return i.info.ModTime()
}

func (i *BundleInfo) IsDir() bool {
	return i.info.IsDir()
}

func (i *BundleInfo) Sys() interface{} {
	return nil
}

func (i *BundleInfo) Path() string {
	return i.path
}

func NewBundleInfo(path string) (os.FileInfo, error) {

	abs_path, err := filepath.Abs(path)

	if err != nil {
		return nil, err
	}

	info, err := os.Stat(abs_path)

	if err != nil {
		return nil, err
	}

	i := BundleInfo{
		path: abs_path,
		info: info,
	}

	return &i, nil
}

func DefaultBundleOptions() *BundleOptions {

	tmpdir := os.TempDir()
	processes := runtime.NumCPU() * 2
	logger := log.SimpleWOFLogger("")

	opts := BundleOptions{
		Source:       "",
		Destination:  tmpdir,
		BundleName:   "",
		Compress:     false,
		Dated:        false,
		SkipExisting: false,
		ForceUpdates: false,
		Processes:    processes,
		Logger:       logger,
	}

	return &opts
}

func NewBundle(options *BundleOptions) (*Bundle, error) {

	b := Bundle{
		Options: options,
	}

	return &b, nil
}

func (b *Bundle) BundleName(metafile string) (string, error) {

	opts := b.Options

	meta_fname := filepath.Base(metafile)
	bundle_name := opts.BundleName

	if bundle_name == "" {

		meta_ext := filepath.Ext(meta_fname)
		bundle_name = strings.Replace(meta_fname, meta_ext, "-bundle", -1)
	}

	if opts.Dated {

		ts := time.Now()
		ymd := ts.Format("20060102") // Go... Y U so weird

		bundle_name = fmt.Sprintf("%s-%s", bundle_name, ymd)
	}

	return bundle_name, nil
}

func (b *Bundle) BundleRoot(metafile string) (string, error) {

	opts := b.Options

	bundle_name, err := b.BundleName(metafile)

	if err != nil {
		return "", nil
	}

	bundle_root := filepath.Join(opts.Destination, bundle_name)

	return filepath.Abs(bundle_root)
}

func (b *Bundle) BundleMetafile(metafile string) (string, error) {

	opts := b.Options

	bundle_root, err := b.BundleRoot(metafile)

	if err != nil {
		return "", err
	}

	info, err := os.Stat(bundle_root)

	if !os.IsNotExist(err) {

		if info.IsDir() {
			return "", errors.New("Bundle already exists, please move it before proceeding")
		}
	}

	bundle_fname := filepath.Base(bundle_root)
	bundle_data := filepath.Join(bundle_root, "data")

	cl, err := clone.NewWOFClone(opts.Source, bundle_data, opts.Processes, opts.Logger)

	if err != nil {
		return "", err
	}

	err = cl.CloneMetaFile(metafile, opts.SkipExisting, opts.ForceUpdates)

	if err != nil {
		return "", err
	}

	// copy the metafile in to the bundle

	meta_fname := filepath.Base(metafile)
	dest_meta := filepath.Join(bundle_root, meta_fname)

	infile, err := os.Open(metafile)

	if err != nil {
		return "", err
	}

	defer infile.Close()

	outfile, err := os.Create(dest_meta)

	if err != nil {
		return "", err
	}

	defer outfile.Close()

	_, err = io.Copy(outfile, infile)

	if err != nil {
		return "", err
	}

	// Add a README

	readme := filepath.Join(bundle_root, "README.md")

	fh, err := os.Create(readme)

	if err != nil {
		return "", err
	}

	ts := time.Now()

	fh.WriteString(fmt.Sprintf("# %s\n\n", bundle_fname))
	fh.WriteString(fmt.Sprintf("This file was generated by robots at %s\n\n", ts.UTC()))

	fh.Close()

	if opts.Compress {

		bundle_root, err = compress.CompressBundle(bundle_root)

		if err != nil {
			return "", err
		}
	}

	return bundle_root, nil
}
